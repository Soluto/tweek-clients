// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Tweek
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost/api/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AppCreationRequestModel
 */
export interface AppCreationRequestModel {
    /**
     * 
     * @type {string}
     * @memberof AppCreationRequestModel
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppCreationRequestModel
     */
    permissions: Array<string>;
}

/**
 * 
 * @export
 * @interface AppCreationResponseModel
 */
export interface AppCreationResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AppCreationResponseModel
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof AppCreationResponseModel
     */
    appSecret: string;
}

/**
 * 
 * @export
 * @interface KeyUpdateModel
 */
export interface KeyUpdateModel {
    /**
     * 
     * @type {any}
     * @memberof KeyUpdateModel
     */
    implementation: any;
    /**
     * 
     * @type {any}
     * @memberof KeyUpdateModel
     */
    manifest: any;
}

/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * 
     * @type {string}
     * @memberof PatchOperation
     */
    op?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchOperation
     */
    path?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchOperation
     */
    value?: any;
}


/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {AppCreationRequestModel} appCreationRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateApp(authorName: string, authorEmail: string, appCreationRequestModel: AppCreationRequestModel, options: any = {}): RequestArgs {
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling appsCreateApp.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling appsCreateApp.');
            }
            // verify required parameter 'appCreationRequestModel' is not null or undefined
            if (appCreationRequestModel === null || appCreationRequestModel === undefined) {
                throw new RequiredError('appCreationRequestModel','Required parameter appCreationRequestModel was null or undefined when calling appsCreateApp.');
            }
            const localVarPath = `/apps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AppCreationRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appCreationRequestModel || {}) : (appCreationRequestModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {AppCreationRequestModel} appCreationRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateApp(authorName: string, authorEmail: string, appCreationRequestModel: AppCreationRequestModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppCreationResponseModel> {
            const localVarAxiosArgs = AppsApiAxiosParamCreator(configuration).appsCreateApp(authorName, authorEmail, appCreationRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {AppCreationRequestModel} appCreationRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateApp(authorName: string, authorEmail: string, appCreationRequestModel: AppCreationRequestModel, options?: any) {
            return AppsApiFp(configuration).appsCreateApp(authorName, authorEmail, appCreationRequestModel, options)(axios, basePath);
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {AppCreationRequestModel} appCreationRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsCreateApp(authorName: string, authorEmail: string, appCreationRequestModel: AppCreationRequestModel, options?: any) {
        return AppsApiFp(this.configuration).appsCreateApp(authorName, authorEmail, appCreationRequestModel, options)(this.axios, this.basePath);
    }

}

/**
 * ConfiguraitonApi - axios parameter creator
 * @export
 */
export const ConfiguraitonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get tweek key value
         * @param {string} keyName Context ids
         * @param {{ [key: string]: string; }} [params] 
         * @param {Array<string>} [$include] Include additional keys
         * @param {boolean} [$flatten] Return flat key/value JSON (no nesting)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValue(keyName: string, params?: { [key: string]: string; }, $include?: Array<string>, $flatten?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling getValue.');
            }
            const localVarPath = `/values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (keyName !== undefined) {
                localVarQueryParameter['keyName'] = keyName;
            }

            if ($include) {
                localVarQueryParameter['$include'] = $include;
            }

            if ($flatten !== undefined) {
                localVarQueryParameter['$flatten'] = $flatten;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfiguraitonApi - functional programming interface
 * @export
 */
export const ConfiguraitonApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get tweek key value
         * @param {string} keyName Context ids
         * @param {{ [key: string]: string; }} [params] 
         * @param {Array<string>} [$include] Include additional keys
         * @param {boolean} [$flatten] Return flat key/value JSON (no nesting)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValue(keyName: string, params?: { [key: string]: string; }, $include?: Array<string>, $flatten?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ConfiguraitonApiAxiosParamCreator(configuration).getValue(keyName, params, $include, $flatten, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ConfiguraitonApi - factory interface
 * @export
 */
export const ConfiguraitonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get tweek key value
         * @param {string} keyName Context ids
         * @param {{ [key: string]: string; }} [params] 
         * @param {Array<string>} [$include] Include additional keys
         * @param {boolean} [$flatten] Return flat key/value JSON (no nesting)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValue(keyName: string, params?: { [key: string]: string; }, $include?: Array<string>, $flatten?: boolean, options?: any) {
            return ConfiguraitonApiFp(configuration).getValue(keyName, params, $include, $flatten, options)(axios, basePath);
        },
    };
};

/**
 * ConfiguraitonApi - object-oriented interface
 * @export
 * @class ConfiguraitonApi
 * @extends {BaseAPI}
 */
export class ConfiguraitonApi extends BaseAPI {
    /**
     * Get tweek key value
     * @param {string} keyName Context ids
     * @param {{ [key: string]: string; }} [params] 
     * @param {Array<string>} [$include] Include additional keys
     * @param {boolean} [$flatten] Return flat key/value JSON (no nesting)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfiguraitonApi
     */
    public getValue(keyName: string, params?: { [key: string]: string; }, $include?: Array<string>, $flatten?: boolean, options?: any) {
        return ConfiguraitonApiFp(this.configuration).getValue(keyName, params, $include, $flatten, options)(this.axios, this.basePath);
    }

}

/**
 * ContextApi - axios parameter creator
 * @export
 */
export const ContextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete identity context property
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {string} prop the property to delete, for example age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContextProp(identityType: string, identityId: string, prop: string, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling deleteContextProp.');
            }
            // verify required parameter 'identityId' is not null or undefined
            if (identityId === null || identityId === undefined) {
                throw new RequiredError('identityId','Required parameter identityId was null or undefined when calling deleteContextProp.');
            }
            // verify required parameter 'prop' is not null or undefined
            if (prop === null || prop === undefined) {
                throw new RequiredError('prop','Required parameter prop was null or undefined when calling deleteContextProp.');
            }
            const localVarPath = `/context/{identityType}/{identityId}/{prop}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)))
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"prop"}}`, encodeURIComponent(String(prop)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(identityType: string, identityId: string, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling getContext.');
            }
            // verify required parameter 'identityId' is not null or undefined
            if (identityId === null || identityId === undefined) {
                throw new RequiredError('identityId','Required parameter identityId was null or undefined when calling getContext.');
            }
            const localVarPath = `/context/{identityType}/{identityId}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)))
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContext(identityType: string, identityId: string, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling saveContext.');
            }
            // verify required parameter 'identityId' is not null or undefined
            if (identityId === null || identityId === undefined) {
                throw new RequiredError('identityId','Required parameter identityId was null or undefined when calling saveContext.');
            }
            const localVarPath = `/context/{identityType}/{identityId}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)))
                .replace(`{${"identityId"}}`, encodeURIComponent(String(identityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextApi - functional programming interface
 * @export
 */
export const ContextApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete identity context property
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {string} prop the property to delete, for example age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContextProp(identityType: string, identityId: string, prop: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ContextApiAxiosParamCreator(configuration).deleteContextProp(identityType, identityId, prop, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(identityType: string, identityId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ContextApiAxiosParamCreator(configuration).getContext(identityType, identityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Save identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContext(identityType: string, identityId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ContextApiAxiosParamCreator(configuration).saveContext(identityType, identityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ContextApi - factory interface
 * @export
 */
export const ContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete identity context property
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {string} prop the property to delete, for example age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContextProp(identityType: string, identityId: string, prop: string, options?: any) {
            return ContextApiFp(configuration).deleteContextProp(identityType, identityId, prop, options)(axios, basePath);
        },
        /**
         * Get identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(identityType: string, identityId: string, options?: any) {
            return ContextApiFp(configuration).getContext(identityType, identityId, options)(axios, basePath);
        },
        /**
         * Save identity context
         * @param {string} identityType the type of the identity - for example user
         * @param {string} identityId the identifier of the identity - for example jaime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContext(identityType: string, identityId: string, options?: any) {
            return ContextApiFp(configuration).saveContext(identityType, identityId, options)(axios, basePath);
        },
    };
};

/**
 * ContextApi - object-oriented interface
 * @export
 * @class ContextApi
 * @extends {BaseAPI}
 */
export class ContextApi extends BaseAPI {
    /**
     * Delete identity context property
     * @param {string} identityType the type of the identity - for example user
     * @param {string} identityId the identifier of the identity - for example jaime
     * @param {string} prop the property to delete, for example age
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public deleteContextProp(identityType: string, identityId: string, prop: string, options?: any) {
        return ContextApiFp(this.configuration).deleteContextProp(identityType, identityId, prop, options)(this.axios, this.basePath);
    }

    /**
     * Get identity context
     * @param {string} identityType the type of the identity - for example user
     * @param {string} identityId the identifier of the identity - for example jaime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public getContext(identityType: string, identityId: string, options?: any) {
        return ContextApiFp(this.configuration).getContext(identityType, identityId, options)(this.axios, this.basePath);
    }

    /**
     * Save identity context
     * @param {string} identityType the type of the identity - for example user
     * @param {string} identityId the identifier of the identity - for example jaime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextApi
     */
    public saveContext(identityType: string, identityId: string, options?: any) {
        return ContextApiFp(this.configuration).saveContext(identityType, identityId, options)(this.axios, this.basePath);
    }

}

/**
 * DependentApi - axios parameter creator
 * @export
 */
export const DependentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Dependents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependents(options: any = {}): RequestArgs {
            const localVarPath = `/dependents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DependentApi - functional programming interface
 * @export
 */
export const DependentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Dependents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependents(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = DependentApiAxiosParamCreator(configuration).getDependents(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DependentApi - factory interface
 * @export
 */
export const DependentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Dependents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependents(options?: any) {
            return DependentApiFp(configuration).getDependents(options)(axios, basePath);
        },
    };
};

/**
 * DependentApi - object-oriented interface
 * @export
 * @class DependentApi
 * @extends {BaseAPI}
 */
export class DependentApi extends BaseAPI {
    /**
     * Get Dependents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentApi
     */
    public getDependents(options?: any) {
        return DependentApiFp(this.configuration).getDependents(options)(this.axios, this.basePath);
    }

}

/**
 * KeysApi - axios parameter creator
 * @export
 */
export const KeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save Key
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {KeyUpdateModel} keyUpdateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(keyPath: string, authorName: string, authorEmail: string, keyUpdateModel: KeyUpdateModel, options: any = {}): RequestArgs {
            // verify required parameter 'keyPath' is not null or undefined
            if (keyPath === null || keyPath === undefined) {
                throw new RequiredError('keyPath','Required parameter keyPath was null or undefined when calling createKey.');
            }
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling createKey.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling createKey.');
            }
            // verify required parameter 'keyUpdateModel' is not null or undefined
            if (keyUpdateModel === null || keyUpdateModel === undefined) {
                throw new RequiredError('keyUpdateModel','Required parameter keyUpdateModel was null or undefined when calling createKey.');
            }
            const localVarPath = `/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyPath !== undefined) {
                localVarQueryParameter['keyPath'] = keyPath;
            }

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KeyUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(keyUpdateModel || {}) : (keyUpdateModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysDeleteKey(keyPath: string, authorName: string, authorEmail: string, requestBody?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'keyPath' is not null or undefined
            if (keyPath === null || keyPath === undefined) {
                throw new RequiredError('keyPath','Required parameter keyPath was null or undefined when calling keysDeleteKey.');
            }
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling keysDeleteKey.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling keysDeleteKey.');
            }
            const localVarPath = `/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyPath !== undefined) {
                localVarQueryParameter['keyPath'] = keyPath;
            }

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} [revision] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGetKey(keyPath: string, revision?: string, options: any = {}): RequestArgs {
            // verify required parameter 'keyPath' is not null or undefined
            if (keyPath === null || keyPath === undefined) {
                throw new RequiredError('keyPath','Required parameter keyPath was null or undefined when calling keysGetKey.');
            }
            const localVarPath = `/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyPath !== undefined) {
                localVarQueryParameter['keyPath'] = keyPath;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeysApi - functional programming interface
 * @export
 */
export const KeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Save Key
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {KeyUpdateModel} keyUpdateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(keyPath: string, authorName: string, authorEmail: string, keyUpdateModel: KeyUpdateModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = KeysApiAxiosParamCreator(configuration).createKey(keyPath, authorName, authorEmail, keyUpdateModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysDeleteKey(keyPath: string, authorName: string, authorEmail: string, requestBody?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = KeysApiAxiosParamCreator(configuration).keysDeleteKey(keyPath, authorName, authorEmail, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} [revision] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGetKey(keyPath: string, revision?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = KeysApiAxiosParamCreator(configuration).keysGetKey(keyPath, revision, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * KeysApi - factory interface
 * @export
 */
export const KeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Save Key
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {KeyUpdateModel} keyUpdateModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(keyPath: string, authorName: string, authorEmail: string, keyUpdateModel: KeyUpdateModel, options?: any) {
            return KeysApiFp(configuration).createKey(keyPath, authorName, authorEmail, keyUpdateModel, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysDeleteKey(keyPath: string, authorName: string, authorEmail: string, requestBody?: Array<string>, options?: any) {
            return KeysApiFp(configuration).keysDeleteKey(keyPath, authorName, authorEmail, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} keyPath 
         * @param {string} [revision] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGetKey(keyPath: string, revision?: string, options?: any) {
            return KeysApiFp(configuration).keysGetKey(keyPath, revision, options)(axios, basePath);
        },
    };
};

/**
 * KeysApi - object-oriented interface
 * @export
 * @class KeysApi
 * @extends {BaseAPI}
 */
export class KeysApi extends BaseAPI {
    /**
     * Save Key
     * @param {string} keyPath 
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {KeyUpdateModel} keyUpdateModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public createKey(keyPath: string, authorName: string, authorEmail: string, keyUpdateModel: KeyUpdateModel, options?: any) {
        return KeysApiFp(this.configuration).createKey(keyPath, authorName, authorEmail, keyUpdateModel, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} keyPath 
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public keysDeleteKey(keyPath: string, authorName: string, authorEmail: string, requestBody?: Array<string>, options?: any) {
        return KeysApiFp(this.configuration).keysDeleteKey(keyPath, authorName, authorEmail, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} keyPath 
     * @param {string} [revision] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public keysGetKey(keyPath: string, revision?: string, options?: any) {
        return KeysApiFp(this.configuration).keysGetKey(keyPath, revision, options)(this.axios, this.basePath);
    }

}

/**
 * ManifestApi - axios parameter creator
 * @export
 */
export const ManifestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Manifests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifests(options: any = {}): RequestArgs {
            const localVarPath = `/manifests`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestApi - functional programming interface
 * @export
 */
export const ManifestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Manifests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifests(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = ManifestApiAxiosParamCreator(configuration).getManifests(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ManifestApi - factory interface
 * @export
 */
export const ManifestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Manifests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManifests(options?: any) {
            return ManifestApiFp(configuration).getManifests(options)(axios, basePath);
        },
    };
};

/**
 * ManifestApi - object-oriented interface
 * @export
 * @class ManifestApi
 * @extends {BaseAPI}
 */
export class ManifestApi extends BaseAPI {
    /**
     * Get Manifests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestApi
     */
    public getManifests(options?: any) {
        return ManifestApiFp(this.configuration).getManifests(options)(this.axios, this.basePath);
    }

}

/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(options: any = {}): RequestArgs {
            const localVarPath = `/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacePolicy(options: any = {}): RequestArgs {
            const localVarPath = `/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Policy
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(patchOperation: Array<PatchOperation>, options: any = {}): RequestArgs {
            // verify required parameter 'patchOperation' is not null or undefined
            if (patchOperation === null || patchOperation === undefined) {
                throw new RequiredError('patchOperation','Required parameter patchOperation was null or undefined when calling updatePolicy.');
            }
            const localVarPath = `/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchOperation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOperation || {}) : (patchOperation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).getPolicies(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Replace Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacePolicy(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).replacePolicy(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Update Policy
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(patchOperation: Array<PatchOperation>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).updatePolicy(patchOperation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(options?: any) {
            return PolicyApiFp(configuration).getPolicies(options)(axios, basePath);
        },
        /**
         * Replace Policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacePolicy(options?: any) {
            return PolicyApiFp(configuration).replacePolicy(options)(axios, basePath);
        },
        /**
         * Update Policy
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(patchOperation: Array<PatchOperation>, options?: any) {
            return PolicyApiFp(configuration).updatePolicy(patchOperation, options)(axios, basePath);
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     * Get Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicies(options?: any) {
        return PolicyApiFp(this.configuration).getPolicies(options)(this.axios, this.basePath);
    }

    /**
     * Replace Policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public replacePolicy(options?: any) {
        return PolicyApiFp(this.configuration).replacePolicy(options)(this.axios, this.basePath);
    }

    /**
     * Update Policy
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public updatePolicy(patchOperation: Array<PatchOperation>, options?: any) {
        return PolicyApiFp(this.configuration).updatePolicy(patchOperation, options)(this.axios, this.basePath);
    }

}

/**
 * RevisionHistoryApi - axios parameter creator
 * @export
 */
export const RevisionHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Revision History
         * @param {string} keyPath 
         * @param {string} since 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionHistory(keyPath: string, since: string, options: any = {}): RequestArgs {
            // verify required parameter 'keyPath' is not null or undefined
            if (keyPath === null || keyPath === undefined) {
                throw new RequiredError('keyPath','Required parameter keyPath was null or undefined when calling getRevisionHistory.');
            }
            // verify required parameter 'since' is not null or undefined
            if (since === null || since === undefined) {
                throw new RequiredError('since','Required parameter since was null or undefined when calling getRevisionHistory.');
            }
            const localVarPath = `/revision-history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyPath !== undefined) {
                localVarQueryParameter['keyPath'] = keyPath;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevisionHistoryApi - functional programming interface
 * @export
 */
export const RevisionHistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Revision History
         * @param {string} keyPath 
         * @param {string} since 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionHistory(keyPath: string, since: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = RevisionHistoryApiAxiosParamCreator(configuration).getRevisionHistory(keyPath, since, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * RevisionHistoryApi - factory interface
 * @export
 */
export const RevisionHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Revision History
         * @param {string} keyPath 
         * @param {string} since 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionHistory(keyPath: string, since: string, options?: any) {
            return RevisionHistoryApiFp(configuration).getRevisionHistory(keyPath, since, options)(axios, basePath);
        },
    };
};

/**
 * RevisionHistoryApi - object-oriented interface
 * @export
 * @class RevisionHistoryApi
 * @extends {BaseAPI}
 */
export class RevisionHistoryApi extends BaseAPI {
    /**
     * Get Revision History
     * @param {string} keyPath 
     * @param {string} since 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevisionHistoryApi
     */
    public getRevisionHistory(keyPath: string, since: string, options?: any) {
        return RevisionHistoryApiFp(this.configuration).getRevisionHistory(keyPath, since, options)(this.axios, this.basePath);
    }

}

/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Schema
         * @param {string} identityType The type of the identity
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentity(identityType: string, authorName: string, authorEmail: string, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling deleteIdentity.');
            }
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling deleteIdentity.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling deleteIdentity.');
            }
            const localVarPath = `/schemas/{identityType}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemas(options: any = {}): RequestArgs {
            const localVarPath = `/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaAddIdentity(identityType: string, authorName: string, authorEmail: string, body: any, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling schemaAddIdentity.');
            }
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling schemaAddIdentity.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling schemaAddIdentity.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling schemaAddIdentity.');
            }
            const localVarPath = `/schemas/{identityType}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaPatchIdentity(identityType: string, authorName: string, authorEmail: string, patchOperation: Array<PatchOperation>, options: any = {}): RequestArgs {
            // verify required parameter 'identityType' is not null or undefined
            if (identityType === null || identityType === undefined) {
                throw new RequiredError('identityType','Required parameter identityType was null or undefined when calling schemaPatchIdentity.');
            }
            // verify required parameter 'authorName' is not null or undefined
            if (authorName === null || authorName === undefined) {
                throw new RequiredError('authorName','Required parameter authorName was null or undefined when calling schemaPatchIdentity.');
            }
            // verify required parameter 'authorEmail' is not null or undefined
            if (authorEmail === null || authorEmail === undefined) {
                throw new RequiredError('authorEmail','Required parameter authorEmail was null or undefined when calling schemaPatchIdentity.');
            }
            // verify required parameter 'patchOperation' is not null or undefined
            if (patchOperation === null || patchOperation === undefined) {
                throw new RequiredError('patchOperation','Required parameter patchOperation was null or undefined when calling schemaPatchIdentity.');
            }
            const localVarPath = `/schemas/{identityType}`
                .replace(`{${"identityType"}}`, encodeURIComponent(String(identityType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorName !== undefined) {
                localVarQueryParameter['author.name'] = authorName;
            }

            if (authorEmail !== undefined) {
                localVarQueryParameter['author.email'] = authorEmail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchOperation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOperation || {}) : (patchOperation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete Schema
         * @param {string} identityType The type of the identity
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentity(identityType: string, authorName: string, authorEmail: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = SchemaApiAxiosParamCreator(configuration).deleteIdentity(identityType, authorName, authorEmail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemas(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = SchemaApiAxiosParamCreator(configuration).getSchemas(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Add identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaAddIdentity(identityType: string, authorName: string, authorEmail: string, body: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = SchemaApiAxiosParamCreator(configuration).schemaAddIdentity(identityType, authorName, authorEmail, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Update identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaPatchIdentity(identityType: string, authorName: string, authorEmail: string, patchOperation: Array<PatchOperation>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = SchemaApiAxiosParamCreator(configuration).schemaPatchIdentity(identityType, authorName, authorEmail, patchOperation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete Schema
         * @param {string} identityType The type of the identity
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentity(identityType: string, authorName: string, authorEmail: string, options?: any) {
            return SchemaApiFp(configuration).deleteIdentity(identityType, authorName, authorEmail, options)(axios, basePath);
        },
        /**
         * Get query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemas(options?: any) {
            return SchemaApiFp(configuration).getSchemas(options)(axios, basePath);
        },
        /**
         * Add identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaAddIdentity(identityType: string, authorName: string, authorEmail: string, body: any, options?: any) {
            return SchemaApiFp(configuration).schemaAddIdentity(identityType, authorName, authorEmail, body, options)(axios, basePath);
        },
        /**
         * Update identity
         * @param {string} identityType 
         * @param {string} authorName 
         * @param {string} authorEmail 
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaPatchIdentity(identityType: string, authorName: string, authorEmail: string, patchOperation: Array<PatchOperation>, options?: any) {
            return SchemaApiFp(configuration).schemaPatchIdentity(identityType, authorName, authorEmail, patchOperation, options)(axios, basePath);
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * Delete Schema
     * @param {string} identityType The type of the identity
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public deleteIdentity(identityType: string, authorName: string, authorEmail: string, options?: any) {
        return SchemaApiFp(this.configuration).deleteIdentity(identityType, authorName, authorEmail, options)(this.axios, this.basePath);
    }

    /**
     * Get query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public getSchemas(options?: any) {
        return SchemaApiFp(this.configuration).getSchemas(options)(this.axios, this.basePath);
    }

    /**
     * Add identity
     * @param {string} identityType 
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaAddIdentity(identityType: string, authorName: string, authorEmail: string, body: any, options?: any) {
        return SchemaApiFp(this.configuration).schemaAddIdentity(identityType, authorName, authorEmail, body, options)(this.axios, this.basePath);
    }

    /**
     * Update identity
     * @param {string} identityType 
     * @param {string} authorName 
     * @param {string} authorEmail 
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaPatchIdentity(identityType: string, authorName: string, authorEmail: string, patchOperation: Array<PatchOperation>, options?: any) {
        return SchemaApiFp(this.configuration).schemaPatchIdentity(identityType, authorName, authorEmail, patchOperation, options)(this.axios, this.basePath);
    }

}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(options: any = {}): RequestArgs {
            const localVarPath = `/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = SearchApiAxiosParamCreator(configuration).search(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(options?: any) {
            return SearchApiFp(configuration).search(options)(axios, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(options?: any) {
        return SearchApiFp(this.configuration).search(options)(this.axios, this.basePath);
    }

}

/**
 * SuggestionsApi - axios parameter creator
 * @export
 */
export const SuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(options: any = {}): RequestArgs {
            const localVarPath = `/suggestions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionsApi - functional programming interface
 * @export
 */
export const SuggestionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = SuggestionsApiAxiosParamCreator(configuration).getSuggestions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SuggestionsApi - factory interface
 * @export
 */
export const SuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(options?: any) {
            return SuggestionsApiFp(configuration).getSuggestions(options)(axios, basePath);
        },
    };
};

/**
 * SuggestionsApi - object-oriented interface
 * @export
 * @class SuggestionsApi
 * @extends {BaseAPI}
 */
export class SuggestionsApi extends BaseAPI {
    /**
     * Get Suggestions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestionsApi
     */
    public getSuggestions(options?: any) {
        return SuggestionsApiFp(this.configuration).getSuggestions(options)(this.axios, this.basePath);
    }

}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save tags
         * @param {any} body The tags that need saving
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(body: any, options: any = {}): RequestArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling saveTag.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Save tags
         * @param {any} body The tags that need saving
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(body: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).saveTag(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).tagsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Save tags
         * @param {any} body The tags that need saving
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(body: any, options?: any) {
            return TagsApiFp(configuration).saveTag(body, options)(axios, basePath);
        },
        /**
         * Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options?: any) {
            return TagsApiFp(configuration).tagsGet(options)(axios, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Save tags
     * @param {any} body The tags that need saving
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public saveTag(body: any, options?: any) {
        return TagsApiFp(this.configuration).saveTag(body, options)(this.axios, this.basePath);
    }

    /**
     * Get all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(options?: any) {
        return TagsApiFp(this.configuration).tagsGet(options)(this.axios, this.basePath);
    }

}

